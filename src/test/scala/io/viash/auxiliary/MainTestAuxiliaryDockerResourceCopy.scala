package io.viash.auxiliary

import io.viash.{DockerTest, TestHelper}
import io.viash.helpers.{IO, Logger}
import org.scalatest.BeforeAndAfterAll
import org.scalatest.funsuite.AnyFunSuite

import java.nio.file.{Files, Paths, StandardCopyOption}
import io.viash.ConfigDeriver

class MainTestAuxiliaryDockerResourceCopy extends AnyFunSuite with BeforeAndAfterAll {
  Logger.UseColorOverride.value = Some(false)
  private val configFile = getClass.getResource("/testbash/auxiliary_resource/config_resource_test.vsh.yaml").getPath
  private val temporaryConfigFolder = IO.makeTemp(s"viash_${this.getClass.getName}_")
  private val configDeriver = ConfigDeriver(Paths.get(configFile), temporaryConfigFolder)

  test("Check resources are copied from and to the correct location", DockerTest) {

    // copy some resources to /tmp/viash_tmp_resources/ so we can test absolute path resources
    val tmpFolderResourceSourceFile = Paths.get(getClass.getResource("/testbash/resource3.txt").getFile)

    val tmpFolderResourceDestinationFolder = Paths.get("/tmp/viash_tmp_resources/").toFile
    val tmpFolderResourceDestinationFile = Paths.get(tmpFolderResourceDestinationFolder.getPath, "resource3.txt")

    if (!tmpFolderResourceDestinationFolder.exists())
      tmpFolderResourceDestinationFolder.mkdir()

    Files.copy(tmpFolderResourceSourceFile, tmpFolderResourceDestinationFile, StandardCopyOption.REPLACE_EXISTING)

    // generate viash script
    val testOutput = TestHelper.testMain(
      workingDir = Some(temporaryConfigFolder),
      "test",
      "--engine", "docker",
      "-k", "true",
      configFile, 
    )

    // basic checks to see if standard test/build was correct
    assert(testOutput.stdout.contains("Running tests in temporary directory: "))
    assert(testOutput.stdout.contains("WARNING! No tests found!"))
    assert(!testOutput.stdout.contains("Cleaning up temporary directory"))

    val FolderRegex = ".*Running tests in temporary directory: '([^']*)'.*".r

    val tempPath = testOutput.stdout.replaceAll("\n", "") match {
      case FolderRegex(path) => path
      case _ => ""
    }

    // List all expected resources and their md5sum
    val expectedResources = List(
      //("check_bash_version.sh", "0c3c134d4ff0ea3a4a3b32e09fb7c100"),
      ("code.sh", ".*"), // turn off checksum match for code.sh, as it changes regularly.
      ("NOTICE", ".*"), // turn off checksum match for notice, as it changes regularly.
      ("resource1.txt", "bc9171172c4723589a247f99b838732d"),
      ("resource2.txt", "9cd530447200979dbf9e117915cbcc74"),
      ("resource_folder/resource_L1_1.txt", "51954bf10062451e683121e58d858417"),
      ("resource_folder/resource_L1_2.txt", "b43991c0ef5d15710faf976e02cbb206"),
      ("resource_folder/resource_L2/resource_L2_1.txt", "63165187f791a8dfff628ef8090e56ff"),
      ("target_folder/relocated_file_1.txt", "bc9171172c4723589a247f99b838732d"),
      ("target_folder/relocated_file_2.txt", "51954bf10062451e683121e58d858417"),
      ("target_folder/relocated_file_3.txt", ".*"), // turn off checksum match, as it changes regularly.
      ("resource3.txt", "aa2037b3d308bcb6a78a3d4fbf04b297"),
      ("resource4.txt", "21cd10137f841da59921aa35de998942"),
      ("target_folder/relocated_file_4.txt", "aa2037b3d308bcb6a78a3d4fbf04b297")
    )

    // Check all resources can be found in the folder
    for ((name, md5sum) <- expectedResources) {
      val resourceFile = Paths.get(tempPath, "build_engine_environment", name).toFile

      assert(resourceFile.exists, s"Could not find $name")

      val hash = TestHelper.computeHash(resourceFile.getPath)

      assert(md5sum.r.findFirstMatchIn(hash).isDefined, s"Calculated md5sum doesn't match the given md5sum for $name")
    }

    IO.deleteRecursively(tmpFolderResourceDestinationFolder.toPath)
    checkTempDirAndRemove(testOutput.stdout, true, "viash_test_auxiliary_resources")
  }

  test("Check resources with unsupported format", DockerTest) {
    val configResourcesUnsupportedProtocolFile = configDeriver.derive(""".resources := [{type: "bash_script", path: "./check_bash_version.sh"}, {path: "ftp://ftp.ubuntu.com/releases/robots.txt"}]""", "config_resource_unsupported_protocol").toString
    // generate viash script
    val testOutput = TestHelper.testMainException[RuntimeException](
      "test",
      "--engine", "docker",
      "-k", "true",
      configResourcesUnsupportedProtocolFile
    )

    assert(testOutput.exceptionText.get == "Unsupported scheme: ftp")

    // basic checks to see if standard test/build was correct
    assert(testOutput.stdout.contains("Running tests in temporary directory: "))
    assert(!testOutput.stdout.contains("WARNING! No tests found!"))
    assert(!testOutput.stdout.contains("Cleaning up temporary directory"))

    checkTempDirAndRemove(testOutput.stdout, true, "viash_test_auxiliary_resources")
  }

  /**
   * Searches the output generated by Main.main() during tests for the temporary directory name and verifies if it still exists or not.
   * If directory was expected to be present and actually is present, it will be removed.
   * @param testText the text generated by Main.main()
   * @param expectDirectoryExists expect the directory to be present or not
   * @return
   */
  def checkTempDirAndRemove(testText: String, expectDirectoryExists: Boolean, testDirName: String = "viash_test_testbash"): Unit = {
    // Get temporary directory
    val FolderRegex = ".*Running tests in temporary directory: '([^']*)'.*".r

    val tempPathStr = testText.replaceAll("\n", "") match {
      case FolderRegex(path) => path
      case _ => ""
    }

    assert(tempPathStr.contains(s"${IO.tempDir}/$testDirName"))

    val tempPath = Paths.get(tempPathStr)

    if (expectDirectoryExists) {
      // Check temporary directory is still present
      assert(Files.exists(tempPath))
      assert(Files.isDirectory(tempPath))

      // Remove the temporary directory
      IO.deleteRecursively(tempPath)
    }

    // folder should always have been removed at this stage
    assert(!Files.exists(tempPath))
  }

  override def afterAll(): Unit = {
    IO.deleteRecursively(temporaryConfigFolder)
  }
}
