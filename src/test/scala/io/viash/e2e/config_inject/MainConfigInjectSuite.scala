package io.viash.e2e.config_inject

import io.viash._

import org.scalatest.BeforeAndAfterAll
import org.scalatest.funsuite.AnyFunSuite
import java.nio.file.{Files, Paths, StandardCopyOption}

import io.viash.config.Config

import scala.io.Source
import io.viash.helpers.{IO, Exec, Logger}

class MainConfigInjectSuite extends AnyFunSuite with BeforeAndAfterAll {
  Logger.UseColorOverride.value = Some(false)
  private val temporaryFolder = IO.makeTemp("viash_tester")

  val srcPath = Paths.get(getClass.getResource(s"/test_languages/").getPath())
  val destPath = temporaryFolder.resolve("inject_test")

  val tests = List(
    ("bash", "config.vsh.yaml", "#", "par_input='input.txt'"),
    ("python", "config.vsh.yaml", "#", "'input': r'input.txt'"),
    // ("r", "script.vsh.R", "//", "input = \"input.txt\""), // TODO add back when `viash config inject` works for inline configs or add separate config/script combo for R
    ("js", "config.vsh.yaml", "//", "'input': String.raw`input.txt`"),
    ("scala", "config.vsh.yaml", "//", "Some(\"\"\"input.txt\"\"\"),"),
    ("csharp", "config.vsh.yaml", "//", "input = @\"input.txt\""),
  )

  test("Prepare temporary folder") {
    destPath.toFile().mkdirs()
    TestHelper.copyFolder(srcPath, destPath)
  }

  for ((name, file, comment, expectedInputString) <- tests) {
    println(s"$name $file $expectedInputString")
    
    test(s"config inject works for $name") {
      // check source file exists
      val configFile = destPath.resolve(s"$name/$file")
      assert(configFile.toFile().exists, "Check dest config exists")

      val functionality = Config.read(configFile.toString()).functionality

      val scriptFile = destPath.resolve(s"$name/" + functionality.mainScript.get.path.get) // assume all of these things exist
      assert(scriptFile.toFile().exists, "Check dest script exists")

      // inject script
      TestHelper.testMain(
        "config", "inject",
        configFile.toString(),
      )

      assert(scriptFile.toFile().exists, "Check dest script still exists")

      val code = Source.fromFile(scriptFile.toString()).getLines().mkString("\n")
      assert(code.contains(s"$comment The following code has been auto-generated by Viash"), "Script has been injected with a Viash header")
      assert(code.contains(expectedInputString), "Script has a default value set for 'input'")

      // run inject script a second time. The result should be the same as running it once (no changes that stack).
      TestHelper.testMain(
        "config", "inject",
        configFile.toString(),
      )
      val code2 = Source.fromFile(scriptFile.toString()).getLines().mkString("\n")

      // these lines change each time config inject is run, clear the random number
      // meta_resources_dir='/tmp/viash_inject_test_languages15183647856847957861'
      // meta_executable='/tmp/viash_inject_test_languages15183647856847957861/test_languages'
      // meta_config='/tmp/viash_inject_test_languages15183647856847957861/.config.vsh.yaml'

      // assume number is a Long, so between 1 and 20 decimal characters
      val code_replacements = code.replaceAll(s"inject_test_languages_$name\\d*", "")
      val code2_replacements = code2.replaceAll(s"inject_test_languages_$name\\d*", "")

      assert(code.length - code_replacements.length <= 126 + (name.length+1)*3, "Stripping the paths should not cause very big differences")
      assert(code.length - code_replacements.length >= 66 + (name.length+1)*3, "Stripping the paths should not cause very big differences, but at least some")
      assert(code2.length - code2_replacements.length <= 126 + (name.length+1)*3, "Stripping the paths should not cause very big differences")
      assert(code2.length - code2_replacements.length >= 66 + (name.length+1)*3, "Stripping the paths should not cause very big differences, but at least some")

      assert(code_replacements.length == code2_replacements.length, "Running config inject multiple times should not result in substantial code differences. Only the placeholder folder is different.")
    }

  }

  override def afterAll(): Unit = {
    IO.deleteRecursively(temporaryFolder)
  }
}