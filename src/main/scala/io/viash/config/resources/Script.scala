/*
 * Copyright (C) 2020  Data Intuitive
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package io.viash.config.resources

import java.net.URI
import io.viash.config.arguments.Argument
import io.viash.config.Config
import io.viash.languages.Language
import io.viash.languages.{Bash, Python, R, JavaScript, Nextflow, Scala, CSharp}

trait Script extends Resource {
  val language: Language

  def generateInjectionMods(argsMetaAndDeps: Map[String, List[Argument[_]]], config: Config): ScriptInjectionMods = {
    language.generateInjectionMods(argsMetaAndDeps, config)
  }

  def readWithInjection(argsMetaAndDeps: Map[String, List[Argument[_]]], config: Config): String = {
    val code = read
    val lines = code.split("\n")
    val startIndex = lines.indexWhere(_.contains("VIASH START"))
    val endIndex = lines.indexWhere(_.contains("VIASH END"))
    
    // compute mods
    val mods = generateInjectionMods(argsMetaAndDeps, config)

    val viashLines = Array(
      language.commentStr + " The following code has been auto-generated by Viash.",
      mods.params
    )

    val li =
      if (startIndex >= 0 && endIndex >= 0) {
        val Whitespace = raw"^(\s+).*".r
        val viashLinesWDelimiter = 
          lines(startIndex) match {
            case Whitespace(prefix) => 
              viashLines.flatMap(_.split("\n")).map(prefix + _)
            case _ => viashLines
          }

        lines.slice(0, startIndex + 1) ++ 
        viashLinesWDelimiter ++ 
        lines.slice(endIndex, lines.length)
      } else {
        Array(language.commentStr + language.commentStr + " VIASH START") ++
        viashLines ++ 
        Array(language.commentStr + language.commentStr + " VIASH END") ++
        lines
      }
    val li2 = 
      { if (mods.header.isEmpty()) Array.empty[String] else Array(mods.header) } ++
      li ++
      { if (mods.footer.isEmpty()) Array.empty[String] else Array(mods.footer) }

    li2.mkString("\n")
  }

  def readWithoutInjection = {
    val code = read
    val lines = code.split("\n")
    val startIndex = lines.indexWhere(_.contains("VIASH START"))
    val endIndex = lines.indexWhere(_.contains("VIASH END"))
    val li = 
      if (startIndex >= 0 && endIndex >= 0) {
        lines.slice(0, startIndex + 1) ++ lines.slice(endIndex, lines.length)
      } else {
        lines
      }
    li.mkString("\n")
  }

  def command(script: String): String = (language.executor :+ s"\"$script\"").mkString(" ")
  def commandSeq(script: String): Seq[String] = language.executor ++ Seq(script)
}

object Script {
  val languages = List(Bash, Python, R, JavaScript, Nextflow, Scala, CSharp)
  val extensions =
    languages
      .flatMap(lang => lang.extensions.map(ext => (ext.toLowerCase, lang)))
      .toMap

  def fromExt(extension: String): Language = {
    extensions(extension.toLowerCase)
  }

  def apply(
    path: Option[String] = None,
    text: Option[String] = None,
    dest: Option[String] = None,
    is_executable: Option[Boolean] = Some(true),
    parent: Option[URI] = None,
    entrypoint: Option[String] = None,
    `type`: String
  ): Script = {
    val languageId = `type`.replaceAll("_script$", "")

    if (languageId != Nextflow.id)
      assert(entrypoint.isEmpty, message = s"Entrypoints are not (yet) supported for resources of type ${`type`}.")

    languageId match {
      case Bash.id =>
        BashScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case CSharp.id =>
        CSharpScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case JavaScript.id =>
        JavaScriptScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case Nextflow.id =>
        assert(entrypoint.isDefined, "In a Nextflow script, the 'entrypoint' argument needs to be specified.")
        NextflowScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent, entrypoint = entrypoint.get)
      case Python.id =>
        PythonScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case R.id =>
        RScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case Scala.id =>
        ScalaScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
    }
  }
}
