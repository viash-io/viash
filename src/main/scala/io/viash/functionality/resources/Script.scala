/*
 * Copyright (C) 2020  Data Intuitive
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package io.viash.functionality.resources

import io.viash.functionality.Functionality

import java.net.URI
import io.viash.functionality.arguments.Argument
import io.viash.config.Config

trait Script extends Resource {
  val companion: ScriptCompanion

  def generateInjectionMods(argsMetaAndDeps: Map[String, List[Argument[_]]], config: Config): ScriptInjectionMods

  def readWithInjection(argsMetaAndDeps: Map[String, List[Argument[_]]], config: Config): Option[String] = {
    read.map(code => {
      val lines = code.split("\n")
      val startIndex = lines.indexWhere(_.contains("VIASH START"))
      val endIndex = lines.indexWhere(_.contains("VIASH END"))
      
      // compute mods
      val mods = generateInjectionMods(argsMetaAndDeps, config)

      val viashLines = Array(
        companion.commentStr + " The following code has been auto-generated by Viash.",
        mods.params
      )

      val li =
        if (startIndex >= 0 && endIndex >= 0) {
          val Whitespace = raw"^(\s+).*".r
          val viashLinesWDelimiter = 
            lines(startIndex) match {
              case Whitespace(prefix) => 
                viashLines.flatMap(_.split("\n")).map(prefix + _)
              case _ => viashLines
            }

          lines.slice(0, startIndex + 1) ++ 
          viashLinesWDelimiter ++ 
          lines.slice(endIndex, lines.length)
        } else {
          Array(companion.commentStr + companion.commentStr + " VIASH START") ++
          viashLines ++ 
          Array(companion.commentStr + companion.commentStr + " VIASH END") ++
          lines
        }
      val li2 = 
        { if (mods.header.isEmpty()) Array.empty[String] else Array(mods.header) } ++
        li ++
        { if (mods.footer.isEmpty()) Array.empty[String] else Array(mods.footer) }

      li2.mkString("\n")
    })
  }

  def command(script: String): String = (companion.executor :+ s"\"$script\"").mkString(" ")
  def commandSeq(script: String): Seq[String] = companion.executor ++ Seq(script)
}

trait ScriptCompanion {
  val commentStr: String
  val extension: String
  val `type`: String
  val executor: Seq[String]
  // def apply(
  //   path: Option[String] = None,
  //   text: Option[String] = None,
  //   dest: Option[String] = None,
  //   is_executable: Option[Boolean] = Some(true),
  //   parent: Option[URI] = None,
  //   entrypoint: Option[String] = None,
  //   `type`: String = `type`
  // ): Script
}

object Script {
  val companions = List(BashScript, PythonScript, RScript, JavaScriptScript, NextflowScript, ScalaScript, CSharpScript)
  val extensions =
    companions
      .map(x => (x.extension.toLowerCase, x))
      .toMap

  def fromExt(extension: String): ScriptCompanion = {
    extensions(extension.toLowerCase)
  }

  def apply(
    path: Option[String] = None,
    text: Option[String] = None,
    dest: Option[String] = None,
    is_executable: Option[Boolean] = Some(true),
    parent: Option[URI] = None,
    entrypoint: Option[String] = None,
    `type`: String
  ): Script = {

    if (`type` != NextflowScript.`type`)
      assert(entrypoint.isEmpty, message = s"Entrypoints are not (yet) supported for resources of type ${`type`}.")

    `type` match {
      case BashScript.`type` =>
        BashScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case CSharpScript.`type` =>
        CSharpScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case JavaScriptScript.`type` =>
        JavaScriptScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case NextflowScript.`type` =>
        NextflowScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent, entrypoint = entrypoint)
      case PythonScript.`type` =>
        PythonScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case RScript.`type` =>
        RScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
      case ScalaScript.`type` =>
        ScalaScript(path = path, text = text, dest = dest, is_executable = is_executable, parent = parent)
    }
  }
}
